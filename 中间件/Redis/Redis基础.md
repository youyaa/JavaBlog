## Redis

一种内存数据库，多用于缓存方向，提供了多种数据类型来支持不同的业务场景。

Redis还支持事务，持久化，LUA脚本，LRU驱动事件，多种集群方式。

### Redis线程模型

Redis内部使用文件事件处理器file event handler，这个文件事件处理器是单线程的，所以redis才被叫做单线程的模型。Redis采用IO多路复用机制同时监听多个socket，根据socket上的事件来选择对应的事件处理器进行处理。

文件事件处理器包含以下几个部分：

1. 多个socket
2. IO多路复用程序
3. 文件事件分派器
4. 事件处理器（连接应答处理器，命令请求处理器，命令回复处理器）

```
操作都是内存级别，没有上下文切换

io多路复用

epoll select ，事件轮询，非阻塞io

没有事件则线程阻塞，有事件则返回，超时也返回

单线程是一个死循环，这就是事件循环

事件轮询在java中就是nio

Redis会将每个客户端套接字都关联一个指令队列，客户端的指令通过队列排队顺序处理
每个客户端套接字也有一个响应队列
Redis的队列不支持消息多播，而pub/sub支持多播
```



### Redis和memcached区别

1. Redis支持更丰富的数据类型（支持更复杂的使用场景）：Redis不仅支持简单的K/V类型的数据，同时还提供list，set，sort set，hash等数据结构。
2. Redis支持数据的持久化，服务重启后从磁盘加载使用。
3. 集群模式。
4. Redis使用单线程的IO多路复用模型，而Memcached是多线程，非阻塞IO复用的网络模型。

### Redis支持的数据结构

- **String**

  Strings 数据结构是简单的key-value类型，value其实不仅是String，也可以是数字.

  常用命令:  set,get,decr,incr,mget 等。

-  **Hash**

  结构化存储。

  常用命令：hget,hset,hgetall 等。

- **List**

  常用命令：lpush,rpush,lpop,rpop,lrange等。

  Redis list的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销，Redis内部的很多实现，包括发送缓冲队列等也都是用的这个数据结构。

- **Set**

  常用命令：sadd,spop,smembers,sunion 等。

  类似list，可以自动排重。

-  **Sorted Set**

  Redis sorted set的使用场景与set类似，区别是set不是自动有序的，而sorted set可以通过用户额外提供一个优先级(score)的参数来为成员排序，并且是插入有序的，即自动排序。

  常用命令：zadd,zrange,zrem,zcard等

  Redis sorted set的内部使用HashMap和跳跃表(SkipList)来保证数据的存储和有序，HashMap里放的是成员到score的映射，而跳跃表里存放的是所有的成员，排序依据是HashMap里存的score,使用跳跃表的结构可以获得比较高的查找效率，并且在实现上比较简单。

- **Pub/Sub**

  Pub/Sub 从字面上理解就是发布（Publish）与订阅（Subscribe），在Redis中，你可以设定对某一个key值进行消息发布及消息订阅，当一个key值上进行了消息发布后，所有订阅它的客户端都会收到相应的消息。这一功能最明显的用法就是用作实时消息系统，比如普通的即时聊天，群聊等功能。

- **Transactions**

- #### 队列

  对于Redis的队列，如果队列没有数据，使用普通的lpop rpush会空轮询，换成blpop

  brpush等阻塞出入队操作会更好。

  阻塞读取指令在队列中没有数据的时候，会立即进行休眠状态，一旦有数据则立即唤醒取数据，

  消息的延迟几乎为0。

- #### HyperLogLog

  用HyperLogLog能够进行UV统计，它提供较为准确的去重操作，比用set做要省空间，效率高

  误差率只有百分之零点81 0.81%，每个HyperLogLog占据12KB内存空间。

- #### bloom filter

  布隆过滤器，对于去重很有效，

  如果它说存在某个值，有可能不存在。如果它说不存在这个值，那么一定不存在。

  如：解决缓存穿透，将所有可能存在的数据缓存放到布隆过滤器中，当黑客访问不存在的缓存时迅速返回避免缓存及DB挂掉。它内部使用一个无偏hash函数，将数据的每个元素进行hash，落在位数组中

  完成add则为1

  向布隆过滤器询问key是否存在时，和add相同，通过hash计算每一个位置对应在位数组中是否为1

  如果均为1则可能存在，如果不为1则一定不存在，从而进行提前过滤明显降低缓存穿透的风险。

### Redis过期数据清理

可以给任意key指定过期时间expire time。那么如何清理过期数据呢？

**定期删除+惰性删除**

- 定期删除：redis默认是每隔 100ms 就随机抽取一些设置了过期时间的key，检查其是否过期，如果过期就删除。注意这里是随机抽取的。为什么要随机呢？你想一想假如 redis 存了几十万个 key ，每隔100ms就遍历所有的设置过期时间的 key 的话，就会给 CPU 带来很大的负载！
- 惰性删除 ：定期删除可能会导致很多过期 key 到了时间并没有被删除掉。所以就有了惰性删除。假如你的过期 key，靠定期删除没有被删除掉，还停留在内存里，除非你的系统去查一下那个 key，才会被redis给删除掉。这就是所谓的惰性删除。

如果定期删除漏掉了很多过期 key，然后你也没及时去查，也就没走惰性删除，此时会怎么样？如果大量过期key堆积在内存里，导致redis内存块耗尽了。怎么解决这个问题呢？ redis 内存淘汰机制。

### Redis内存淘汰机制

redis 提供 6种数据淘汰策略：

1. volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰
2. volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰
3. volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰
4. allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（这个是最常用的）
5. allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰
6. no-eviction：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！

4.0版本后增加以下两种：

1. volatile-lfu：从已设置过期时间的数据集(server.db[i].expires)中挑选最不经常使用的数据淘汰
2. allkeys-lfu：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的key

### Redis持久化策略

#### rdb（redis database）-- 快照持久化

rdb是redis的一种数据持久化策略，redis将某一时间点的数据全部打包生成一个dump.rdb的文件，保存在磁盘中。

#### 手动生成rdb快照

- redis客户端发送bgsave命令来创建rdb快照
- redis客户端发送save命令来创建rdb快照
- redis客户端发送shutdown命令，redis服务端会在收到命令后先产生rdb快照，再关闭服务

#### 自动生成rdb快照：

- redis基于redis配置文件的 save规则进行自动生成快照：

  | save 900 1           | 距离上一次执行rdb快照时间超过900秒，并且至少有1个键发生了改变，便会触发备份操作 |
  | -------------------- | ------------------------------------------------------------ |
  | save 300 10          | 距离上一次执行rdb快照时间超过300秒，并且至少有10个键发生了改变，便会触发备份操作 |
  | save 60 10000 (默认) | 距离上一次执行rdb快照时间超过60秒，并且至少有1000个键发生了改变，便会触发备份操作 |

#### 生成步骤

实际操作过程是fork一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。

#### RDB的优点

1). **单文件备份**: 一旦采用该方式，那么你的整个Redis数据库将只包含一个文件，这对于文件备份而言是非常完美的。

2). **恢复简单**: 对于灾难恢复而言，RDB是非常不错的选择。因为我们可以非常轻松的将一个单独的文件压缩后再转移到其它存储介质上。

3). **性能最大化** : 对于Redis的服务进程而言，在开始持久化时，它唯一需要做的只是fork出子进程，之后再由子进程完成这些持久化的工作，这样就可以极大的避免服务进程执行IO操作了。

4). 相比于AOF机制，如果数据集很大，RDB的**启动效率会更高**。

#### RDB的缺点

1). **数据丢失** ： 如果你想保证数据的高可用性，即最大限度的避免数据丢失，那么RDB将不是一个很好的选择。因为系统一旦在定时持久化之前出现宕机现象，此前没有来得及写入磁盘的数据都将丢失。

2). **停顿** ： 由于RDB是通过fork子进程来协助完成数据持久化工作的，因此，如果当数据集较大时，可能会导致整个服务器停止服务几百毫秒，甚至是1秒钟。

#### aof（append only file ） -- 只追加文件持久化

aof同样是redis的持久化策略，采用该策略的时候，redis会将被执行的写命令添加到aof文件的末尾，该文件被保留在磁盘中。当重启redis服务的时候会优先（相对于rdb文件而言）读取aof文件，完成对redis数据的恢复。

与快照持久化相比，AOF持久化 的实时性更好，因此已成为主流的持久化方案。默认情况下Redis没有开启AOF（append only file）方式的持久化，可以通过appendonly参数开启：**appendonly yes**

在Redis的配置文件中存在三种不同的 AOF 持久化方式，它们分别是：

```java
appendfsync always    #每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度 

appendfsync everysec  #每秒钟同步一次，显示地将多个写命令同步到硬盘 

appendfsync no        #让操作系统决定何时进行同步
```

为了兼顾数据和写入性能，用户可以考虑 appendfsync everysec选项 ，让Redis每秒同步一次AOF文件，Redis性能几乎没受到任何影响。而且这样即使出现系统崩溃，用户最多只会丢失一秒之内产生的数据。当硬盘忙于执行写入操作的时候，Redis还会优雅的放慢自己的速度以便适应硬盘的最大写入速度。

#### AOF 的优点

- AOF 只是追加日志文件，因此对服务器性能影响较小，速度比 RDB 要快，消耗的内存较少。

#### AOF 的缺点

- AOF 方式生成的日志文件太大，即使通过 AFO 重写，文件体积仍然很大。
- 恢复数据的速度比 RDB 慢。

#### 总结

当 RDB 与 AOF 两种方式都开启时，Redis 会优先使用 AOF 日志来恢复数据，因为 AOF 保存的文件比 RDB 文件更完整。

### Redis事务

不能保证原子性。

### Redis并发竞争key问题

多个系统同时对一个key进行操作，但最后的执行顺序和期望的不一样，这就导致了结果的不同。

解决方案：分布式锁

基于Zookeeper临时有序节点的实现方案：加锁时在指定节点目录下生成临时有序的节点。判断是否

## Redis的注意点

1. Redis是单线程请求，应该尽量避免耗时较高的单个请求任务，防止影响其他任务
2. Redis服务应该避免与其他CPU密集型的进程部署在同一个机器上
3. 禁用Redis所在机器的swap内存交换，防止Redis缓存数据交换到硬盘上

> QPS TPS要关注响应时间，我们定义在百分之九十九处于800ms内

