## 二叉树的存储

链式存储

顺序存储：如果节点 X 存储在数组中下标为 i 的位置，下标为 2 * i 的位置存储的就是左子节点，下标为 2 * i + 1 的位置存储的就是右子节点。完全二叉树最适合用数组来存储。

## 二叉搜索(查找)树

（1）左子树上所有节点的值均小于或等于它的根结点的值。

（2）右子树上所有节点的值均大于或等于它的根结点的值。

一组数据可以构建出多种二叉查找树。在不做任何调整，而且极端情况下，会退化成链表。

完全二叉树的高度小于等于 log2N。

## 平衡二叉树

二叉查找树在极端条件下会退化成链表。需要定义一种可以自平衡的结构。

平衡二叉树的性质： 

它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。

这个方案很好的解决了二叉查找树退化成链表的问题，把插入，查找，删除的时间复杂度最好情况和最坏情况都维持在O(logN)。

但是频繁旋转会使插入和删除牺牲掉O(logN)左右的时间，不过相对二叉查找树来说，时间上稳定了很多。

最先被发明的平衡二叉查找树是AVL 树，它严格符合我刚讲到的平衡二叉查找树的定义，即任何节点的左右子树高度相差不超过 1，是一种高度平衡的二叉查找树。

## 红黑树

红黑树的性质：

1.节点是红色或黑色。

2.根节点是黑色。

3.每个叶子节点都是黑色的空节点（NIL节点）。

4 红色节点被黑色节点隔开。

5.从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。

这些约束强制了红黑树的关键性质: 从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。结果是这个树大致上是平衡的。因为操作比如插入、删除和查找某个值的最坏情况时间都要求与树的高度成比例，这个在高度上的理论上限允许红黑树在最坏情况下都是高效的，而不同于普通的二叉查找树。


**区别：** 

1、红黑树放弃了追求完全平衡，追求大致平衡，在与平衡二叉树的时间复杂度相差不大的情况下，保证每次插入最多只需要三次旋转就能达到平衡，实现起来也更为简单。

2、平衡二叉树追求绝对平衡，条件比较苛刻，实现起来比较麻烦，每次插入新节点之后需要旋转的次数不能预知。

## 堆排序

1. 堆是一个完全二叉树；

2. 堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值。

