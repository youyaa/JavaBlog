## 何为进程，何为线程

**进程：**

是指内存中运行的一个应用程序，每个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程；进程也是程序的一次执行过程，是系统运行程序的基本单位；系统运行一个程序即是一个进程从创建、运行到消亡的过程。

**线程：**

进程内部的一个独立执行单元；一个进程可以同时并发的运行多个线程，所以线程也被称为轻量级进程。线程是CPU调度的最小单位，线程的切换可能会引起进程的切换。

> Hotspot JVM 中的 Java 线程与原生操作系统线程有直接的映射关系。当线程本地存储、缓冲区分配、同步对象、栈、程序计数器等准备好以后，就会创建一个操作系统原生线程。 Java 线程结束，原生线程随之被回收。操作系统负责调度所有线程，并把它们分配到任何可用的 CPU 上。当原生线程初始化完毕，就会调用 Java 线程的 run() 方法。当线程结束时，会释放原生线程和 Java 线程的所有资源。

## 线程状态和切换

操作系统定义的线程状态：

1. 新建  New
2. 就绪  Ready                    **表示线程已经被创建，正在等待CPU调度。**
3. 运行  Running                **表示线程获得了CPU使用权，正在进行运算**
4. 阻塞  Blocked                 **表示线程阻塞，让出CPU的使用权**
5. 消亡  Terminated

JAVA中定义的线程状态：

查看Thread类的源码：

```java
public enum State {
        NEW,
        RUNNABLE,         
        BLOCKED,          
        WAITING,					
        TIMED_WAITING,
        TERMINATED;
    }
```

1. NEW ：             新建。

2. RUNNABLE：  可运行。可能正在运行，也可能在等待CPU调度。

3. BLOCKED：     锁阻塞。当线程等待 synchronized 的隐式锁。synchronized 修饰的方法、代码块同一时刻只允许一个线程执行，其他线程只能等待，这种情况下，等待的线程就会从 RUNNABLE 转换到 BLOCKED 状态。而当等待的线程获得 synchronized 隐式锁时，就又会从 BLOCKED 转换到 RUNNABLE 状态。

4. WAITING：      无限等待。一个线程在等待另一个线程执行一个（唤醒）动作时，该线程进入Waiting状态。进入这个状态后是不能自动唤醒的，必须等待另一个线程调用notify或者notifyAll方法才能够唤醒。**调用wait()，join()和LockSupport.park()**会进入这个状态。

5. TIMED_WAITING： 计时等待。 同waiting状态，有几个方法有超时参数，调用他们将进入Timed Waiting状态。这一状态将一直保持到超时期满或者接收到唤醒通知。**带有超时参数的常用方法有Thread.sleep 、Object.wait，Thread.join(long millis)，LockSupport.parkNanos(Object blocker, long deadline)。**

6. TERMINATED： 终止。

   > 一般有四种方式能终止线程：
   >
   > 1. 程序运行结束，自动终止。
   >
   > 2. 使用退出标志位退出线程。
   > 3. 使用interrupt()退出线程。有两种情况：当程序处于阻塞状态时，调用线程的interrupt()方法会抛出InterruptException，捕获该异常，通过break结束。当程序处于未阻塞状态时，使用isInterrupt()判断线程是否被中断，当线程被interrupt()时，中断标志位为true，和退出标志位差不多。
   > 4. 使用stop()等方法，不推荐。

## 线程死锁

多个线程都在等待一个或者多个资源被释放，同时被阻塞。

### 产生死锁的原因

操作系统课程中说，线程死锁必须具备以下四个条件：

1. 互斥条件：资源在同一时刻只能由一个线程占用。
2. 请求与保持条件：一个进程因资源而阻塞时，对已拥有的资源保持不放。
3. 不剥夺条件：线程已获得的资源在完全使用之前不能被其他线程强行剥夺，只能由自己使用完毕之后释放。
4. 循环等待条件：若干线程之间形成一种头尾相接的循环等待关系。

### 如何避免死锁

破坏其中一个条件即可。

#### 破坏互斥条件

独占锁的特性，无法破坏。

#### 破坏请求与保持条件

资源一次性申请。

#### 破坏不可剥夺条件 

占用资源的线程在申请其他资源时，申请不到，主动释放自己已经占有的资源

#### 破坏循环等待条件

将资源统一编号，按照序号申请。



## 活跃性问题

### 活锁

可以类比现实世界里的例子，路人甲从左手边出门，路人乙从右手边进门，两人为了不相撞，互相谦让，路人甲让路走右手边，路人乙也让路走左手边，结果是两人又相撞了。这种情况，基本上谦让几次就解决了，因为人会交流啊。可是如果这种情况发生在编程世界了，就有可能会一直没完没了地“谦让”下去，成为没有发生阻塞但依然执行不下去的“活锁”。

解决“活锁”的方案很简单，谦让时，尝试等待一个随机的时间就可以了。例如上面的那个例子，路人甲走左手边发现前面有人，并不是立刻换到右手边，而是等待一个随机的时间后，再换到右手边；同样，路人乙也不是立刻切换路线，也是等待一个随机的时间再切换。由于路人甲和路人乙等待的时间是随机的，所以同时相撞后再次相撞的概率就很低了。“等待一个随机时间”的方案虽然很简单，却非常有效，Raft 这样知名的分布式一致性算法中也用到了它。

### 饥饿

所谓“饥饿”指的是线程因无法访问所需资源而无法执行下去的情况。“不患寡，而患不均”，如果线程优先级“不均”，在 CPU 繁忙的情况下，优先级低的线程得到执行的机会很小，就可能发生线程“饥饿”；持有锁的线程，如果执行的时间过长，也可能导致“饥饿”问题。

解决“饥饿”问题的方案很简单，有三种方案：一是保证资源充足，二是公平地分配资源，三就是避免持有锁的线程长时间执行。这三个方案中，方案一和方案三的适用场景比较有限，因为很多场景下，资源的稀缺性是没办法解决的，持有锁的线程执行的时间也很难缩短。倒是方案二的适用场景相对来说更多一些。那如何公平地分配资源呢？在并发编程里，主要是使用公平锁。所谓公平锁，是一种先来后到的方案，线程的等待是有顺序的，排在等待队列前面的线程会优先获得资源。



## 上下文切换

概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。**任务从保存到再加载的过程就是一次上下文切换**。



## 伪唤醒

在循环中检查等待条件