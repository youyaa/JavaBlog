## 为什么需要分布式锁

1. **避免不同节点重复相同的工作**：比如用户执行了某个操作有可能不同节点会发送多封邮件；
2. **避免破坏数据的正确性**：如果两个节点在同一条数据上同时进行操作，可能会造成数据错误或不一致的情况出现；



## 特点

**互斥性:** 和我们本地锁一样互斥性是最基本，但是分布式锁需要保证在不同节点的不同线程的互斥。

**可重入性:**   同一个节点上的同一个线程如果获取了锁之后那么也可以再次获取这个锁。

**锁超时:** 和本地锁一样支持锁超时，防止死锁。

**高可用:**   加锁和解锁需要高效，同时也需要保证高可用防止分布式锁失效，可以增加降级。

**支持阻塞和非阻塞: **和ReentrantLock一样支持lock和trylock以及tryLock(long timeOut)。

**支持公平锁和非公平锁(可选):**  公平锁的意思是按照请求加锁的顺序获得锁，非公平锁就相反是无序的。这个一般来说实现的比较少。



## 常见实现方式

1. **基于 MySQL 中的锁**：MySQL 本身有自带的悲观锁 `for update` 关键字，也可以自己实现悲观/乐观锁来达到目的；
2. **基于 Zookeeper 有序节点**：Zookeeper 允许临时创建有序的子节点，这样客户端获取节点列表时，就能够当前子节点列表中的序号判断是否能够获得锁；
3. **基于 Redis 的单线程**：由于 Redis 是单线程，所以命令会以串行的方式执行，并且本身提供了像 `SETNX(set if not exists)` 这样的指令，本身具有互斥性；



参考资料：https://juejin.im/post/5bbb0d8df265da0abd3533a5#heading-0